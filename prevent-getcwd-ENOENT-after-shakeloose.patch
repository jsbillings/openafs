From a7c23ddfb57b2b5e369307151cf910106d444984 Mon Sep 17 00:00:00 2001
From: Mark Vitale <mvitale@sinenomine.net>
Date: Fri, 1 Dec 2017 13:51:25 -0500
Subject: [PATCH] LINUX: RH7.4: prevent getcwd() ENOENT after shakeloose

Linux 3.18 commit 5542aa2fa7f6 "vfs: Make d_invalidate return void"
changed both d_invalidate's signature and semantics.  Previously, it
would not unhash a dentry in use, but now it will always unhash the
specified dentry. Various OpenAFS commits have been written to cope with
this over the years; the most recent being:
c3bbf0b LINUX: do not use d_invalidate to evict dentries
19599b5 LINUX: eliminate unused variable warning

RH 7.4 (3.10.0-695-el7) introduced the same semantic change for
d_invalidate, but without the signature change.  Unfortunately,  OpenAFS
relied on an autoconf test for the signature change to detect the
semantic change.  Thus with RH 7.4, OpenAFS "shakeloose" calls to
d_invalidate may once again invalidate a dentry in use, e.g. the current
working directory.

Detecting this semantic change with another autoconf test, or with a runtime
test, were both deemed too fragile and complex.

Instead, change osi_TryEvictDentries() to use shrink_dcache_parent in
lieu of d_invalidate (too aggressive) or d_prune_aliases (not aggressive
enough).

This essentially reverts 1.6.x commits:
    c392d79 LINUX: do not use d_invalidate to evict dentries
    e64639b LINUX: eliminate unused variable warning

It is safe to leave the very old (before 2.6.38) HAVE_DCACHE_LOCK logic
intact, because we know d_invalidate worked fine for our purposes back
then.

Change-Id: Ia472f2145c547f321f0c9457af4cb495386d160c
---
 src/afs/LINUX/osi_vcache.c | 18 +-----------------
 1 file changed, 1 insertion(+), 17 deletions(-)

diff --git a/src/afs/LINUX/osi_vcache.c b/src/afs/LINUX/osi_vcache.c
index 52830c555..9cf1ee4b5 100644
--- a/src/afs/LINUX/osi_vcache.c
+++ b/src/afs/LINUX/osi_vcache.c
@@ -18,21 +18,12 @@
 static void
 TryEvictDentries(struct vcache *avc)
 {
-#ifndef D_INVALIDATE_IS_VOID
     struct dentry *dentry;
-#endif
     struct inode *inode = AFSTOV(avc);
 #if defined(D_ALIAS_IS_HLIST) && !defined(HLIST_ITERATOR_NO_NODE)
     struct hlist_node *p;
 #endif
 
-#if defined(D_INVALIDATE_IS_VOID)
-    /* At this kernel level, d_invalidate always succeeds;
-     * that is, it will now invalidate even an active directory,
-     * Therefore we must use a different method to evict dentries.
-     */
-    d_prune_aliases(inode);
-#else
 #if defined(HAVE_DCACHE_LOCK)
     spin_lock(&dcache_lock);
 
@@ -56,7 +47,6 @@ restart:
 #else /* HAVE_DCACHE_LOCK */
     spin_lock(&inode->i_lock);
 
-restart:
 #if defined(D_ALIAS_IS_HLIST)
 # if defined(HLIST_ITERATOR_NO_NODE)
     hlist_for_each_entry(dentry, &inode->i_dentry, d_alias) {
@@ -75,19 +65,13 @@ restart:
 	dget(dentry);
 
 	spin_unlock(&inode->i_lock);
-	if (afs_d_invalidate(dentry) == -EBUSY) {
-	    dput(dentry);
-	    /* perhaps lock and try to continue? (use cur as head?) */
-	    goto inuse;
-	}
+	shrink_dcache_parent(dentry);
 	dput(dentry);
 	spin_lock(&inode->i_lock);
-	goto restart;
     }
     spin_unlock(&inode->i_lock);
 #endif /* HAVE_DCACHE_LOCK */
 inuse:
-#endif /* D_INVALIDATE_IS_VOID */
     return;
 }
 
-- 
2.14.3

